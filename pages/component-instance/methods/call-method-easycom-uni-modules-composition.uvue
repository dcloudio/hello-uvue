<template>
  <view>
    <call-easy-method-uni-modules ref="callEasyMethod1"></call-easy-method-uni-modules>
  </view>
</template>

<script setup lang="uts">
import { testInOtherFile } from './call-method-easycom-uni-modules'

const delay = (): Promise<string> =>
  new Promise((resolve, _) => {
    setTimeout(() => {
      resolve('')
    }, 1000)
  })

const callEasyMethod1 = ref<CallEasyMethodUniModulesComponentPublicInstance | null>(null)

const callMethod1 = () => {
  // 调用组件的 foo1 方法
  callEasyMethod1.value!.foo1()
}
const callMethod2 = () => {
  // 调用组件的 foo2 方法并传递 1个参数
  callEasyMethod1.value!.foo2(Date.now())
}
const callMethod3 = () => {
  // 调用组件的 foo3 方法并传递 2个参数
  callEasyMethod1.value!.foo3(Date.now(), Date.now())
}
const callMethod4 = () => {
  // 调用组件的 foo4 方法并传递 callback
  callEasyMethod1.value!.foo4(() => {
    console.log('callback')
  })
}
const callMethod5 = () => {
  // 注意： 返回值可能为 null，当前例子一定不为空，所以加了 !
  const result = callEasyMethod1.value!.foo5('string5') as string
  console.log(result) // string1
}
const callMethodTest = (text: string): string | null => {
  const result = callEasyMethod1.value!.foo5(text) as string
  return result
}
const callMethodInOtherFile = (text: string): string => {
  return testInOtherFile(callEasyMethod1.value!, text)
}

const call = async (): Promise<void> => {
  callMethod1()
  await delay()
  callMethod2()
  await delay()
  callMethod3()
  await delay()
  callMethod4()
  await delay()
  callMethod5()
}

onReady(() => {
  call()
})

defineExpose({
  callMethodTest,
  callMethodInOtherFile
})
</script>